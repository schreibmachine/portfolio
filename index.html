<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Portfolio Vi Schreiber</title>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

        <meta name="description" content="This is the portfolio website from Vi Schreiber" />
        <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
        
        <script type="text/javascript" src="projects.json"></script>
        <!-- instead of cannon.js, we are now using Rapier on top of THREE -->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://esm.sh/three@0.163.0",
                    "three/addons/": "https://esm.sh/three@0.163.0/examples/jsm/",
                    "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat", 
                    "@monogrid/gainmap-js": "https://esm.sh/@monogrid/gainmap-js@3.0.5"
                }
            }
        </script>
    </head>
    <body>
        <div class="main" id="section1">
            <img id= "star1" src="img/star_blue.PNG" class="star rotate linear infinite"/>
            <!-- <h1>VI SCHREIBER</h1>
            <h2>PORTFOLIO WEBSITE</h2>
            <br>
            <br>
            <div class="renderer-container"></div> -->
            
            <div class="hero-layout">
                <div class="hero-text">
                    <h1>VI SCHREIBER</h1>
                    <h2>PORTFOLIO WEBSITE</h2>
                    <a href="#section2" class="nav-button" id="toAboutMe">About Me</a>
                </div>

                <div id="renderer-container"></div>

            </div>
            
            
            
            <!-- popups! -->
            <!-- <button id="openPopup" style="width: 150px; padding: 10px 0px; background-color: #28a745; color: #fff; border: none; border-radius: 5px;">Open Popup</button> -->
            <div id="popup" class="popup">
                <div class="modal">
                    
                    <button id="closePopup" class="close-btn">âœ•</button>
                    
                    <div class="modal-grid">
                        <img id="popMainImage" class="titleImg" alt="Title image displaying the name of the project" />
                        
                        <div class="text-block">
                            <h1 id="popTitle"></h1>
                            <p id="popTagline"></p>
                        </div>
                        
                        <div class="text-block">
                            <h2 id="teamHeadline">Made by</h2>
                            <p id="popTeam" style="text-align: right; font-size: 18px;"></p>
                            <h2 id="teamHeadline">for</h2>
                            <p id="popClient" style="text-align: right; font-size: 15px;"></p>
                        </div>
                        
                        <p id="popText" class="description"></p>
                        
                        <!-- video gallery -->
                        <div id="popVideoGallery" class="video-gallery"></div>
                        <!-- image gallery  -->
                        <div id="popGallery"></div>

                    </div>

                </div>
            </div>

   
        </div>
        <script type="module">
            import * as THREE from 'three'
            // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
            import Stats from 'three/addons/libs/stats.module.js'
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
            import RAPIER from '@dimforge/rapier3d-compat'

            // prevent hash navigation on load/reload ---------------------------------------------------------
            window.addEventListener("load", () => {
                if (window.location.hash) {
                    history.replaceState(null, null, " ");
                    window.scrollTo(0, 0);
                    // jkhskdjhfksdjhf
                }
            });


            // nav button logic -------------------------------------------------------------------------------
            const btnAbout = document.getElementById('toAboutMe');
            const btnBack = document.getElementById('toLanding');
            const btnMail = document.getElementById("btnMail")
            
            //toggling the visibility between the buttons...
            btnAbout.addEventListener('click', () => {
                btnAbout.style.display = 'none';

                btnBack.style.display = 'block';
                btnMail.style.display = 'block';
            });

            btnBack.addEventListener('click', () => {
                btnAbout.style.display = 'block';
                btnBack.style.display = 'none';
                btnMail.style.display = 'none';
            });

            
            // popup logic ------------------------------------------------------------------------------------
            const popup = document.getElementById('popup');
            const popImg = document.getElementById('popMainImage');
            const popTitle = document.getElementById('popTitle');
            const popTagline = document.getElementById('popTagline');
            const popTeamEpicContainer = document.getElementById('popTeam');
            const popText = document.getElementById('popText');
            const galleryContainer = document.getElementById('popGallery');
            const videoGalleryContainer = document.getElementById('popVideoGallery');
            const popClient = document.getElementById('popClient');

            // this creates and fills the popup for each project
            function openPopupForProject(index) {
                // disable about button when popup is open
                btnAbout.style.display = 'none';

                const project = projectsArray[index];
                if (!project) return;

                popImg.src = project.mainImage;
                popTitle.textContent = project.title;
                popTagline.textContent = project.tagline;


                // Team List
                popTeamEpicContainer.innerHTML = ''; // clear previous
                if (project.team && project.team.length) {
                    project.team.forEach(teammember => {
                        popTeamEpicContainer.innerHTML += teammember + '\n';
                    });

                } else {
                    popTeamEpicContainer.innerHTML += 'Vi Schreiber';
                }
                // Client Text
                popClient.textContent = project.client || 'myself';

                popText.textContent = project.description;


                // YouTube embed gallery, if available
                videoGalleryContainer.innerHTML = ''; // clear previous
                if (project.videoLinks && project.videoLinks.length) {
                    const embedLinks = project.videoLinks.filter(link => link.includes('embed'));
                    embedLinks.forEach(link => {
                        const videoIframe = document.createElement('iframe');
                        videoIframe.src = link;
                        videoIframe.style.width = '100%'; // Adjust width according to your design
                        videoIframe.style.height = '315px'; // Adjust height as needed
                        videoIframe.setAttribute('frameborder', '0');
                        videoIframe.setAttribute('allowfullscreen', true);
                        videoGalleryContainer.appendChild(videoIframe);
                    });
                    videoGalleryContainer.style.display = 'block';
                } else {
                    videoGalleryContainer.style.display = 'none';
                }

                // Image Gallery
                galleryContainer.innerHTML = ''; // clear previous
                if (project.imgGallery && project.imgGallery.length) {
                    project.imgGallery.forEach(url => {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.objectFit = 'contain'; // ensure aspect ratio is respected
                        galleryContainer.appendChild(img);
                        // console.log('Added gallery image:', url);
                    });
                    galleryContainer.style.display = 'flex';

                } else {
                    galleryContainer.style.display = 'none';
                }

                popup.classList.add('active');
            }

            // for the closing the popup button i think
            document.getElementById('closePopup').addEventListener('click', () => {
                popup.classList.remove('active');
                btnAbout.style.display = 'block';
            });

            // fetching the JSON & create cubes when finished ------------------------------------------------

            let projectsArray = []; // stores the JSON once fetched

            window.addEventListener('DOMContentLoaded', () => {
            fetch('https://raw.githubusercontent.com/schreibmachine/portfolio/refs/heads/main/projects.json')
                .then(res => res.json())
                .then(data => {
                    // when data is fetched:
                    projectsArray = data; // save the array for later
                    console.log(projectsArray.length + ' projects loaded. Details: ', projectsArray);

                    // Will create a new cube every n milliseconds (intervalID needed to kill it when finished) - here, to wai
                    intervalID ??= window.setInterval(createCube, 1000);

                })
                .catch(err => console.error('Failed to load projects.json:', err));
            });
     


            // -------------------------------------------------------------------------------------------

            class RapierDebugRenderer {
                mesh
                world
                enabled = true

                constructor(scene, world) {
                    this.world = world
                    this.mesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true }))
                    this.mesh.frustumCulled = false
                    scene.add(this.mesh)
                }


                update() {
                    if (this.enabled) {
                        const { vertices, colors } = world.debugRender()
                        this.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))
                        this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4))
                        this.mesh.visible = true
                    } else {
                        this.mesh.visible = false
                    }
                }
            }

            await RAPIER.init() // This line is needed!
            const gravity = new RAPIER.Vector3(0.0, -9.81, 0.0)
            const world = new RAPIER.World(gravity)
            const dynamicBodies = []

            let cubeCounter = 0
            let cubeCounter_offset = 0.0
            let intervalID

            const scene = new THREE.Scene()

            const rapierDebugRenderer = new RapierDebugRenderer(scene, world)

            const light1 = new THREE.SpotLight(undefined, Math.PI * 10)
            light1.position.set(2.5, 5, 5)
            light1.angle = Math.PI / 1.8
            light1.penumbra = 0.5
            light1.castShadow = true
            light1.shadow.blurSamples = 10
            light1.shadow.radius = 5
            scene.add(light1)

            const light2 = light1.clone()
            light2.position.set(-2.5, 5, 5)
            scene.add(light2)

            const framePadding = 0.1
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100)
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100)
            camera.position.set(0, 2, 5)

            const renderer = new THREE.WebGLRenderer({ antialias: true })

            function clamp(num, min, max) {
                return Math.min(Math.max(num, min), max);
            }
            let clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 1080);
            let clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 1080);
            // renderer.setSize(clampedWidth, clampedHeight)
            //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }

            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.VSMShadowMap

            renderer.domElement.id = 'myCoolRenderer';
            document.getElementById("renderer-container").appendChild(renderer.domElement);



            window.addEventListener('resize', () => {
                // set overall viewport:
                setViewportHeight();

                // renderer things:
                camera.aspect = 1 // keep square!
                camera.updateProjectionMatrix()
                clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 900);
                clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 900);

                //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }
            })
            
            function setViewportHeight() {
                document.documentElement.style.setProperty(
                    '--vh',
                    `${window.innerHeight * 0.01}px`
                );
            }

            setViewportHeight();


            function createTextTexture(pText, pColor, width = 256, height = 256, padding = 10) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Background (optional)
                ctx.fillStyle = pColor;
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Function to split text into lines that fit the canvas
                function wrapText(ctx, pText, maxWidth) {
                    const words = pText.split(' ');
                    const lines = [];
                    let line = '';

                    for (let word of words) {
                        const testLine = line + (line ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && line) {
                            lines.push(line);
                            line = word;
                        } else {
                            line = testLine;
                        }
                    }
                    lines.push(line);
                    return lines;
                }

                // Start with a big font size and shrink until it fits
                let fontSize = 80;
                ctx.font = `bold ${fontSize}px Arial`;

                let lines = wrapText(ctx, pText, width - 2 * padding);

                while (lines.length * fontSize > height - 2 * padding && fontSize > 10) {
                    fontSize -= 2;
                    ctx.font = `bold ${fontSize}px Arial`;
                    lines = wrapText(ctx, pText, width - 2 * padding);
                }

                // Draw the lines centered vertically
                const lineHeight = fontSize * 1.2;
                const totalHeight = lines.length * lineHeight;
                let y = height / 2 - totalHeight / 2 + lineHeight / 2;

                for (let line of lines) {
                    ctx.fillText(line, width / 2, y);
                    y += lineHeight;
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }


            function createCube() {
                cubeCounter++;

                const id = `cube_${cubeCounter}`;

                // Create a canvas texture with the project title and color
                const projectTitle = projectsArray[cubeCounter-1]?.title || 'Error';
                const projectColor = projectsArray[cubeCounter-1]?.color || 'black';
                const textTexture = createTextTexture(projectTitle,projectColor);

                // Use MeshBasicMaterial so lighting doesn't affect visibility
                const materials = Array(6).fill(new THREE.MeshBasicMaterial({ map: textTexture }));

                const cubeMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 0.5),
                    materials
                );

                cubeMesh.name = id;
                cubeMesh.userData.body = null;  
                cubeMesh.userData.projectIndex = cubeCounter - 1; // store index for popup

                scene.add(cubeMesh);

                const cubeBody = world.createRigidBody(
                    RAPIER.RigidBodyDesc.dynamic()
                        .setTranslation(-1 + (cubeCounter % 3), 7, 2.5)
                        .setCanSleep(false)
                );

                const cubeShape = RAPIER.ColliderDesc
                    .cuboid(0.25, 0.25, 0.25)
                    .setMass(1)
                    .setRestitution(0.5);

                world.createCollider(cubeShape, cubeBody);

                cubeMesh.userData.body = cubeBody;

                dynamicBodies.push(cubeMesh);

                if (cubeCounter >= projectsArray.length) {
                    clearInterval(intervalID);
                }
            }



            function createBall(name) {
                
                // Ball Collider
                const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshNormalMaterial())
                sphereMesh.castShadow = true
                scene.add(sphereMesh)
                const sphereBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 5, 2.5).setCanSleep(false))
                const sphereShape = RAPIER.ColliderDesc.ball(.2).setMass(1).setRestitution(0.5)
                world.createCollider(sphereShape, sphereBody)
                dynamicBodies.push([sphereMesh, sphereBody])
            }

            
            /*
            // ConvexHull Collider
            const icosahedronMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), new THREE.MeshNormalMaterial())
            icosahedronMesh.castShadow = true
            scene.add(icosahedronMesh)
            const icosahedronBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2.5, 5, 0).setCanSleep(false))
            const points = new Float32Array(icosahedronMesh.geometry.attributes.position.array)
            const icosahedronShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
            world.createCollider(icosahedronShape, icosahedronBody)
            dynamicBodies.push([icosahedronMesh, icosahedronBody])

            // Trimesh Collider
            const torusKnotMesh = new THREE.Mesh(new THREE.TorusKnotGeometry(), new THREE.MeshNormalMaterial())
            torusKnotMesh.castShadow = true
            scene.add(torusKnotMesh)
            const torusKnotBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2, 10, 0))
            const vertices = new Float32Array(torusKnotMesh.geometry.attributes.position.array)
            let indices = new Uint32Array(torusKnotMesh.geometry.index.array)
            const torusKnotShape = RAPIER.ColliderDesc.trimesh(vertices, indices).setMass(1).setRestitution(0.5)
            world.createCollider(torusKnotShape, torusKnotBody)
            dynamicBodies.push([torusKnotMesh, torusKnotBody])
            */

            // the floor (using a cuboid)
            const floorMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 1, 50), new THREE.MeshPhongMaterial({color: '#36e817', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            floorMesh.receiveShadow = true
            floorMesh.position.y = 0
            scene.add(floorMesh)
            const floorBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorMesh.position.y, 0))
            const floorShape = RAPIER.ColliderDesc.cuboid(25, 0.5, 25)
            world.createCollider(floorShape, floorBody)

            // the left side (using a cuboid)
            const sideLMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideLMesh.receiveShadow = true
            sideLMesh.position.y = -1
            sideLMesh.position.x = -2
            scene.add(sideLMesh)
            const sideLBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideLMesh.position.x, sideLMesh.position.y, sideLMesh.position.z))
            const sideLShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideLShape, sideLBody)

            // the RIGHT side (using a cuboid)
            const sideRMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideRMesh.receiveShadow = true
            sideRMesh.position.y = -1
            sideRMesh.position.x = 2
            scene.add(sideRMesh)
            const sideRBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideRMesh.position.x, sideRMesh.position.y, sideRMesh.position.z))
            const sideRShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideRShape, sideRBody)

            
            // the BACK side (using a cuboid)
            const sideBMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 1), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideBMesh.receiveShadow = true
            sideBMesh.position.z = 1.5
            scene.add(sideBMesh)
            const sideBBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideBMesh.position.x, sideBMesh.position.y, sideBMesh.position.z))
            const sideBShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(sideBShape, sideBBody)
            
            // the FRONT side (using a cuboid) - invisible(no mat)
            const frontalBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 3.25))
            const frontalShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(frontalShape, frontalBody)

            /*
            // creating a shape from a loaded geometry. (Using OBJLoader)
            new OBJLoader().loadAsync('./models/suzanne.obj').then((object) => {
                //console.log(object)
                scene.add(object)
                const suzanneMesh = object.getObjectByName('Suzanne')
                suzanneMesh.material = new THREE.MeshNormalMaterial()
                suzanneMesh.castShadow = true

                const suzanneBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-1, 10, 0).setCanSleep(false))
                const points = new Float32Array(suzanneMesh.geometry.attributes.position.array)
                const suzanneShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
                world.createCollider(suzanneShape, suzanneBody)
                dynamicBodies.push([suzanneMesh, suzanneBody])
            })
            */

            // DO STUFF WHEN CLICKING A CUBE -----------------------------------------------------
            const raycaster = new THREE.Raycaster()
            const mouse = new THREE.Vector2()

            renderer.domElement.addEventListener('pointerdown', (e) => {
                const rect = renderer.domElement.getBoundingClientRect();

                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(dynamicBodies, false);

                if (!intersects.length) return;

                const mesh = intersects[0].object;
                const body = mesh.userData.body;

                // Find the index of this mesh in dynamicBodies
                const index = dynamicBodies.indexOf(mesh);

                console.log("Clicked cube index:", index);

                if (index !== -1) {
                    // go into the AI created pop up function lol
                    openPopupForProject(index);

                    // popup.style.display = 'flex';
                }

                body.applyImpulse(new RAPIER.Vector3(0, 10, 0), true);
            });




            // const stats = new Stats()
            // document.body.appendChild(stats.dom)

            // const gui = new GUI()
            // gui.add(rapierDebugRenderer, 'enabled').name('Rapier Degug Renderer')

            // const physicsFolder = gui.addFolder('Physics')
            // physicsFolder.add(world.gravity, 'x', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'y', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'z', -10.0, 10.0, 0.1)

            const clock = new THREE.Clock()
            let delta

            function animate() {
                requestAnimationFrame(animate)

                delta = clock.getDelta()
                world.timestep = Math.min(delta, 0.01)
                world.step()

                for (const mesh of dynamicBodies) {
                    const body = mesh.userData.body;
                    const pos = body.translation();
                    const rot = body.rotation();

                    mesh.position.set(pos.x, pos.y, pos.z);
                    mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                }


                
                // rapierDebugRenderer.update()
                
                // controls.update()
                
                renderer.render(scene, camera)
                
                // stats.update().
            }

            animate()
            
        </script>

        <div class="main" id="section2">

            <a href="#section1" class="nav-button" id="toLanding" style="display:none;">Back</a>

            <div class="about-grid">

                <div class="about-photo">
                    <img src="https://img.freepik.com/premium-photo/painting-dolphins-rainbow-sky_948935-1079.jpg?w=2000" alt="Portrait of Vi Schreiber">
                </div>

                <div class="about-text">
                    <h1>About Me</h1>
                    <p>
                        This website is currently under construction!
                        Add bio text here.
                    </p>
                </div>

                <div class="about-links">
                    <h2>Links</h2>
                    <a href="mailto:vi.schreiber@posteo.de" class="nav-button" id="btnMail" style="position: absolute; top: 70%; display:none;">Send Me an E-Mail!</a>
                </div>
                
            </div>
            
        </div>

    </body>
</html>
