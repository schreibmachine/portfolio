<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Portfolio Vi Schreiber</title>
        <meta name="description" content="Using Rapier from CDN" />
        <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
        <style>
            body {
                overflow: hidden;
                margin: 0px;
            }
        </style>
        
        <!-- instead of cannon.js, we are now using Rapier on top of THREE -->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://esm.sh/three@0.163.0",
                    "three/addons/": "https://esm.sh/three@0.163.0/examples/jsm/",
                    "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat", 
                    "@monogrid/gainmap-js": "https://esm.sh/@monogrid/gainmap-js@3.0.5"
                }
            }
        </script>
    </head>
    <body>
        <h1>VI SCHREIBER</h1>
        <h2>PORTFOLIO WEBSITE</h2>
        <button type="button" onclick="alert('Hello world!')">Click Me!</button>
        <script type="module">
            import * as THREE from 'three'
            // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
            import Stats from 'three/addons/libs/stats.module.js'
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
            import RAPIER from '@dimforge/rapier3d-compat'

            class RapierDebugRenderer {
                mesh
                world
                enabled = true

                constructor(scene, world) {
                    this.world = world
                    this.mesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true }))
                    this.mesh.frustumCulled = false
                    scene.add(this.mesh)
                }


                update() {
                    if (this.enabled) {
                        const { vertices, colors } = world.debugRender()
                        this.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))
                        this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4))
                        this.mesh.visible = true
                    } else {
                        this.mesh.visible = false
                    }
                }
            }

            await RAPIER.init() // This line is only needed if using the compat version
            const gravity = new RAPIER.Vector3(0.0, -9.81, 0.0)
            const world = new RAPIER.World(gravity)
            const dynamicBodies = []

            const scene = new THREE.Scene()

            const rapierDebugRenderer = new RapierDebugRenderer(scene, world)

            const light1 = new THREE.SpotLight(undefined, Math.PI * 10)
            light1.position.set(2.5, 5, 5)
            light1.angle = Math.PI / 1.8
            light1.penumbra = 0.5
            light1.castShadow = true
            light1.shadow.blurSamples = 10
            light1.shadow.radius = 5
            scene.add(light1)

            const light2 = light1.clone()
            light2.position.set(-2.5, 5, 5)
            scene.add(light2)

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100)
            camera.position.set(0, 2, 5)

            const renderer = new THREE.WebGLRenderer({ antialias: true })
            renderer.setSize(window.innerWidth, window.innerHeight)
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.VSMShadowMap
            document.body.appendChild(renderer.domElement)
            renderer.domElement.id = 'myCoolRenderer'

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
            })

            // Cuboid Collider
            const cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshNormalMaterial())
            cubeMesh.castShadow = true
            scene.add(cubeMesh)
            const cubeBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-5, 5, 0).setCanSleep(false))
            const cubeShape = RAPIER.ColliderDesc.cuboid(0.5, 0.5, 0.5).setMass(1).setRestitution(0.5)
            world.createCollider(cubeShape, cubeBody)
            dynamicBodies.push([cubeMesh, cubeBody])

            // Ball Collider
            const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(), new THREE.MeshNormalMaterial())
            sphereMesh.castShadow = true
            scene.add(sphereMesh)
            const sphereBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-2.5, 5, 0).setCanSleep(false))
            const sphereShape = RAPIER.ColliderDesc.ball(1).setMass(1).setRestitution(0.5)
            world.createCollider(sphereShape, sphereBody)
            dynamicBodies.push([sphereMesh, sphereBody])

            // Cylinder Collider
            const cylinderMesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 16), new THREE.MeshNormalMaterial())
            cylinderMesh.castShadow = true
            scene.add(cylinderMesh)
            const cylinderBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 5, 0).setCanSleep(false))
            const cylinderShape = RAPIER.ColliderDesc.cylinder(1, 1).setMass(1).setRestitution(0.5)
            world.createCollider(cylinderShape, cylinderBody)
            dynamicBodies.push([cylinderMesh, cylinderBody])

            // ConvexHull Collider
            const icosahedronMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), new THREE.MeshNormalMaterial())
            icosahedronMesh.castShadow = true
            scene.add(icosahedronMesh)
            const icosahedronBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2.5, 5, 0).setCanSleep(false))
            const points = new Float32Array(icosahedronMesh.geometry.attributes.position.array)
            const icosahedronShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
            world.createCollider(icosahedronShape, icosahedronBody)
            dynamicBodies.push([icosahedronMesh, icosahedronBody])

            // Trimesh Collider
            const torusKnotMesh = new THREE.Mesh(new THREE.TorusKnotGeometry(), new THREE.MeshNormalMaterial())
            torusKnotMesh.castShadow = true
            scene.add(torusKnotMesh)
            const torusKnotBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(5, 5, 0))
            const vertices = new Float32Array(torusKnotMesh.geometry.attributes.position.array)
            let indices = new Uint32Array(torusKnotMesh.geometry.index.array)
            const torusKnotShape = RAPIER.ColliderDesc.trimesh(vertices, indices).setMass(1).setRestitution(0.5)
            world.createCollider(torusKnotShape, torusKnotBody)
            dynamicBodies.push([torusKnotMesh, torusKnotBody])

            // the floor (using a cuboid)
            const floorMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 1, 50), new THREE.MeshPhongMaterial())
            floorMesh.receiveShadow = true
            floorMesh.position.y = -1
            scene.add(floorMesh)
            const floorBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, -1, 0))
            const floorShape = RAPIER.ColliderDesc.cuboid(25, 0.5, 25)
            world.createCollider(floorShape, floorBody)

            /*
            // creating a shape from a loaded geometry. (Using OBJLoader)
            new OBJLoader().loadAsync('./models/suzanne.obj').then((object) => {
                //console.log(object)
                scene.add(object)
                const suzanneMesh = object.getObjectByName('Suzanne')
                suzanneMesh.material = new THREE.MeshNormalMaterial()
                suzanneMesh.castShadow = true

                const suzanneBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-1, 10, 0).setCanSleep(false))
                const points = new Float32Array(suzanneMesh.geometry.attributes.position.array)
                const suzanneShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
                world.createCollider(suzanneShape, suzanneBody)
                dynamicBodies.push([suzanneMesh, suzanneBody])
            })
            */

            const raycaster = new THREE.Raycaster()
            const mouse = new THREE.Vector2()

            renderer.domElement.addEventListener('click', (e) => {
                mouse.set((e.clientX / renderer.domElement.clientWidth) * 2 - 1, -(e.clientY / renderer.domElement.clientHeight) * 2 + 1)

                raycaster.setFromCamera(mouse, camera)

                const intersects = raycaster.intersectObjects(
                    dynamicBodies.flatMap((a) => a[0]),
                    false
                )

                if (intersects.length) {
                    dynamicBodies.forEach((b) => {
                        b[0] === intersects[0].object && b[1].applyImpulse(new RAPIER.Vector3(0, 10, 0), true)
                    })
                }
            })

            const stats = new Stats()
            document.body.appendChild(stats.dom)

            const gui = new GUI()
            gui.add(rapierDebugRenderer, 'enabled').name('Rapier Degug Renderer')

            const physicsFolder = gui.addFolder('Physics')
            physicsFolder.add(world.gravity, 'x', -10.0, 10.0, 0.1)
            physicsFolder.add(world.gravity, 'y', -10.0, 10.0, 0.1)
            physicsFolder.add(world.gravity, 'z', -10.0, 10.0, 0.1)

            const clock = new THREE.Clock()
            let delta

            function animate() {
                requestAnimationFrame(animate)

                delta = clock.getDelta()
                world.timestep = Math.min(delta, 0.01)
                world.step()

                for (let i = 0, n = dynamicBodies.length; i < n; i++) {
                    dynamicBodies[i][0].position.copy(dynamicBodies[i][1].translation())
                    dynamicBodies[i][0].quaternion.copy(dynamicBodies[i][1].rotation())
                }

                rapierDebugRenderer.update()

                // controls.update()

                renderer.render(scene, camera)

                stats.update()
            }

            animate()
        </script>
    </body>
</html>
