<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Portfolio Vi Schreiber</title>
        <meta name="description" content="Using Rapier from CDN" />
        <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
        
        <!-- instead of cannon.js, we are now using Rapier on top of THREE -->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://esm.sh/three@0.163.0",
                    "three/addons/": "https://esm.sh/three@0.163.0/examples/jsm/",
                    "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat", 
                    "@monogrid/gainmap-js": "https://esm.sh/@monogrid/gainmap-js@3.0.5"
                }
            }
        </script>
    </head>
    <body>
        <div class="main" id="section1">
            <img id= "star1" src="img/star_blue.PNG" class="rotate linear infinite" width="150" height="150" position = 'absolute' />
            <h1>VI SCHREIBER</h1>
            <h2>PORTFOLIO WEBSITE</h2>
            <!-- <button type="button" onclick="alert('Hello world!')">Click Me!</button> -->
            <button id="starButton"> click for cubes! </button>
            <!-- <a id="btnLebenslauf" href="#section2"> Lebenslauf </button> -->
            <a href="#section2">About Me</a>
        </div>
        <script type="module">
            import * as THREE from 'three'
            // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
            import Stats from 'three/addons/libs/stats.module.js'
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
            import RAPIER from '@dimforge/rapier3d-compat'

            // background
            function show_image(src, width, height, alt) {
                var img = document.createElement("img");
                img.src = src;
                img.width = width;
                img.height = height;
                img.alt = alt;
                
                // set the position
                img.style.position = 'absolute';
                img.style.top = document.body.clientHeight * Math.random() + 'px';
                img.style.left = document.body.clientWidth * Math.random() + 'px';

                document.body.appendChild(img);
            }
            document.getElementById('starButton').addEventListener('click', () =>
                createCube('testKollege')
                // show_image("img/star_blue.PNG", 100, 100, "a hand-drawn blue star"),
                // show_image("img/star_red.PNG", 200, 200, "a hand-drawn red star"),
                // show_image("img/star_yellow.PNG", 200, 200, "a hand-drawn yellow star")
            );
            // document.getElementById('star1').style.top = document.body.clientHeight * Math.random() + 'px';
            // document.getElementById('star1').style.left = document.body.clientHeight * Math.random() + 'px';
            // document.getElementById('star1').style.class = "rotate linear infinite";

            class RapierDebugRenderer {
                mesh
                world
                enabled = true

                constructor(scene, world) {
                    this.world = world
                    this.mesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true }))
                    this.mesh.frustumCulled = false
                    scene.add(this.mesh)
                }


                update() {
                    if (this.enabled) {
                        const { vertices, colors } = world.debugRender()
                        this.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))
                        this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4))
                        this.mesh.visible = true
                    } else {
                        this.mesh.visible = false
                    }
                }
            }

            await RAPIER.init() // This line is only needed if using the compat version
            const gravity = new RAPIER.Vector3(0.0, -9.81, 0.0)
            const world = new RAPIER.World(gravity)
            const dynamicBodies = []

            let cubeCounter = 0
            let cubeCounter_offset = 0.0
            let intervalID

            const scene = new THREE.Scene()

            const rapierDebugRenderer = new RapierDebugRenderer(scene, world)

            const light1 = new THREE.SpotLight(undefined, Math.PI * 10)
            light1.position.set(2.5, 5, 5)
            light1.angle = Math.PI / 1.8
            light1.penumbra = 0.5
            light1.castShadow = true
            light1.shadow.blurSamples = 10
            light1.shadow.radius = 5
            scene.add(light1)

            const light2 = light1.clone()
            light2.position.set(-2.5, 5, 5)
            scene.add(light2)

            const framePadding = 0.1
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100)
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100)
            camera.position.set(0, 2, 5)

            const renderer = new THREE.WebGLRenderer({ antialias: true })

            function clamp(num, min, max) {
                return Math.min(Math.max(num, min), max);
            }
            let clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 1080);
            let clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 1080);
            // renderer.setSize(clampedWidth, clampedHeight)
            //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }

            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.VSMShadowMap
            document.body.appendChild(renderer.domElement)
            renderer.domElement.id = 'myCoolRenderer'

            window.addEventListener('resize', () => {
                camera.aspect = 1 //window.innerWidth / window.innerHeight  
                camera.updateProjectionMatrix()
                clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 1080);
                clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 1080);

                //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }
                // renderer.setSize(window.innerWidth - (framePadding * window.innerWidth) , window.innerHeight - (framePadding * window.innerHeight))
            })

            function createCube(name) {
                cubeCounter++
                console.log('cubeCounter: ' + cubeCounter)

                cubeCounter_offset = cubeCounter % 20
                // console.log('cubeCounter_offset: ' +  cubeCounter_offset)

                // Cuboid Collider
                const cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshNormalMaterial())
                cubeMesh.castShadow = true
                scene.add(cubeMesh)
                const cubeBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation((-1 + cubeCounter_offset / 10), 7, 2.5).setCanSleep(false))
                const cubeShape = RAPIER.ColliderDesc.cuboid(0.2, 0.2, 0.2).setMass(1).setRestitution(0.5)
                world.createCollider(cubeShape, cubeBody)
                dynamicBodies.push([cubeMesh, cubeBody])

                if (cubeCounter >= 20) {
                    clearInterval(intervalID)
                }
            }

            function createBall(name) {

                // Ball Collider
                const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(), new THREE.MeshNormalMaterial())
                sphereMesh.castShadow = true
                scene.add(sphereMesh)
                const sphereBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-2.5, 5, 0).setCanSleep(false))
                const sphereShape = RAPIER.ColliderDesc.ball(1).setMass(1).setRestitution(0.5)
                world.createCollider(sphereShape, sphereBody)
                dynamicBodies.push([sphereMesh, sphereBody])
            }

            
            /*
            // ConvexHull Collider
            const icosahedronMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), new THREE.MeshNormalMaterial())
            icosahedronMesh.castShadow = true
            scene.add(icosahedronMesh)
            const icosahedronBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2.5, 5, 0).setCanSleep(false))
            const points = new Float32Array(icosahedronMesh.geometry.attributes.position.array)
            const icosahedronShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
            world.createCollider(icosahedronShape, icosahedronBody)
            dynamicBodies.push([icosahedronMesh, icosahedronBody])

            // Trimesh Collider
            const torusKnotMesh = new THREE.Mesh(new THREE.TorusKnotGeometry(), new THREE.MeshNormalMaterial())
            torusKnotMesh.castShadow = true
            scene.add(torusKnotMesh)
            const torusKnotBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2, 10, 0))
            const vertices = new Float32Array(torusKnotMesh.geometry.attributes.position.array)
            let indices = new Uint32Array(torusKnotMesh.geometry.index.array)
            const torusKnotShape = RAPIER.ColliderDesc.trimesh(vertices, indices).setMass(1).setRestitution(0.5)
            world.createCollider(torusKnotShape, torusKnotBody)
            dynamicBodies.push([torusKnotMesh, torusKnotBody])
            */

            // the floor (using a cuboid)
            const floorMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 1, 50), new THREE.MeshPhongMaterial({color: '#36e817', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            floorMesh.receiveShadow = true
            floorMesh.position.y = 0
            scene.add(floorMesh)
            const floorBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorMesh.position.y, 0))
            const floorShape = RAPIER.ColliderDesc.cuboid(25, 0.5, 25)
            world.createCollider(floorShape, floorBody)

            // the left side (using a cuboid)
            const sideLMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideLMesh.receiveShadow = true
            sideLMesh.position.y = -1
            sideLMesh.position.x = -2
            scene.add(sideLMesh)
            const sideLBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideLMesh.position.x, sideLMesh.position.y, sideLMesh.position.z))
            const sideLShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideLShape, sideLBody)

            // the RIGHT side (using a cuboid)
            const sideRMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideRMesh.receiveShadow = true
            sideRMesh.position.y = -1
            sideRMesh.position.x = 2
            scene.add(sideRMesh)
            const sideRBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideRMesh.position.x, sideRMesh.position.y, sideRMesh.position.z))
            const sideRShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideRShape, sideRBody)

            
            // the BACK side (using a cuboid)
            const sideBMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 1), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideBMesh.receiveShadow = true
            sideBMesh.position.z = 1.5
            scene.add(sideBMesh)
            const sideBBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideBMesh.position.x, sideBMesh.position.y, sideBMesh.position.z))
            const sideBShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(sideBShape, sideBBody)
            
            // the FRONT side (using a cuboid) - invisible(no mat)
            const frontalBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 3.25))
            const frontalShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(frontalShape, frontalBody)

            /*
            // creating a shape from a loaded geometry. (Using OBJLoader)
            new OBJLoader().loadAsync('./models/suzanne.obj').then((object) => {
                //console.log(object)
                scene.add(object)
                const suzanneMesh = object.getObjectByName('Suzanne')
                suzanneMesh.material = new THREE.MeshNormalMaterial()
                suzanneMesh.castShadow = true

                const suzanneBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-1, 10, 0).setCanSleep(false))
                const points = new Float32Array(suzanneMesh.geometry.attributes.position.array)
                const suzanneShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
                world.createCollider(suzanneShape, suzanneBody)
                dynamicBodies.push([suzanneMesh, suzanneBody])
            })
            */

            const raycaster = new THREE.Raycaster()
            const mouse = new THREE.Vector2()

            renderer.domElement.addEventListener('click', (e) => {
                mouse.set((e.clientX / renderer.domElement.clientWidth) * 2 - 1, -(e.clientY / renderer.domElement.clientHeight) * 2 + 1)

                raycaster.setFromCamera(mouse, camera)

                const intersects = raycaster.intersectObjects(
                    dynamicBodies.flatMap((a) => a[0]),
                    false
                )

                if (intersects.length) {
                    dynamicBodies.forEach((b) => {
                        b[0] === intersects[0].object && b[1].applyImpulse(new RAPIER.Vector3(0, 10, 0), true)
                    })
                }
            })

            // const stats = new Stats()
            // document.body.appendChild(stats.dom)

            // const gui = new GUI()
            // gui.add(rapierDebugRenderer, 'enabled').name('Rapier Degug Renderer')

            // const physicsFolder = gui.addFolder('Physics')
            // physicsFolder.add(world.gravity, 'x', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'y', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'z', -10.0, 10.0, 0.1)

            const clock = new THREE.Clock()
            let delta

            function animate() {
                requestAnimationFrame(animate)

                delta = clock.getDelta()
                world.timestep = Math.min(delta, 0.01)
                world.step()

                for (let i = 0, n = dynamicBodies.length; i < n; i++) {
                    dynamicBodies[i][0].position.copy(dynamicBodies[i][1].translation())
                    dynamicBodies[i][0].quaternion.copy(dynamicBodies[i][1].rotation())
                }

                
                // rapierDebugRenderer.update()
                
                // controls.update()
                
                renderer.render(scene, camera)
                
                // stats.update().
            }
            createCube('theFirst')
                     
            // Will create a new cube every 1.5 seconds (intervalID i needed to kill it when finished)
            intervalID ??= window.setInterval(createCube, 1500);


            animate()
            
        </script>

        <div class="main" id="section2">
            <a href="#section1">Click Me to get back up!</a>
            This website is currently under construction!

            This section will be the "About Me"
        </div>
        <!-- background -->
    </body>
</html>
