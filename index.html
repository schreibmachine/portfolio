<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Portfolio Vi Schreiber</title>
        <meta name="description" content="This is the portfolio website from Vi Schreiber" />
        <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
        
        <script type="text/javascript" src="projects.json"></script>
        <!-- instead of cannon.js, we are now using Rapier on top of THREE -->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://esm.sh/three@0.163.0",
                    "three/addons/": "https://esm.sh/three@0.163.0/examples/jsm/",
                    "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat", 
                    "@monogrid/gainmap-js": "https://esm.sh/@monogrid/gainmap-js@3.0.5"
                }
            }
        </script>
    </head>
    <body>
        <div class="main" id="section1">
            <img id= "star1" src="img/star_blue.PNG" class="rotate linear infinite" width="150" height="150" position = 'absolute' />
            <h1>VI SCHREIBER</h1>
            <h2>PORTFOLIO WEBSITE</h2>
            <br> 
            <!-- <button id="starButton"style="width: 150px; padding: 10px 0px; background-color: #28a745; color: #fff; border: none; border-radius: 5px;">click for cubes!</button> -->
            <br>
            <a href="#section2"style="width: 150px; padding: 10px 0px; background-color: #28a745; color: #fff; border: none; border-radius: 5px;">About Me</a>
            <br>
            
            <!-- popups! -->
            <!-- <button id="openPopup" style="width: 150px; padding: 10px 0px; background-color: #28a745; color: #fff; border: none; border-radius: 5px;">Open Popup</button> -->
            <div id="popup" class="popup">
                <div class="modal">

                    <button id="closePopup" class="close-btn">âœ•</button>

                    <div class="modal-grid">
                        <img id="popMainImage" alt="Title image displaying the name of the project" />

                        <div class="text-block">
                            <!-- <h1 id="popTitle"></h1> -->
                            <p id="popTagline"></p>
                        </div>

                        <p id="popText" class="description"></p>

                        <!-- video gallery -->
                        <div id="popVideoGallery" class="video-gallery">
                        <!-- image gallery  -->
                        <div id="popGallery" class="image-gallery"></div>

                    </div>

                </div>
            </div>

   
        </div>
        <script type="module">
            import * as THREE from 'three'
            // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
            import Stats from 'three/addons/libs/stats.module.js'
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
            import RAPIER from '@dimforge/rapier3d-compat'

            // background --------------------------------------------------------------------------------
            function show_image(src, width, height, alt) {
                var img = document.createElement("img");
                img.src = src;
                img.width = width;
                img.height = height;
                img.alt = alt;
                
                // set the position
                img.style.position = 'absolute';
                img.style.top = document.body.clientHeight * Math.random() + 'px';
                img.style.left = document.body.clientWidth * Math.random() + 'px';

                document.body.appendChild(img);
            }
            // document.getElementById('starButton').addEventListener('click', () =>
            //     createCube('testKollege')
            //     // show_image("img/star_blue.PNG", 100, 100, "a hand-drawn blue star"),
            //     // show_image("img/star_red.PNG", 200, 200, "a hand-drawn red star"),
            //     // show_image("img/star_yellow.PNG", 200, 200, "a hand-drawn yellow star")
            // );
            // document.getElementById('star1').style.top = document.body.clientHeight * Math.random() + 'px';
            // document.getElementById('star1').style.left = document.body.clientHeight * Math.random() + 'px';
            // document.getElementById('star1').style.class = "rotate linear infinite";
            // -------------------------------------------------------------------------------------------

            
            // popup logic -------------------------------------------------------------------------------
            const popup = document.getElementById('popup');
            const popImg = document.getElementById('popMainImage');
            const popTitle = document.getElementById('popTitle');
            const popTagline = document.getElementById('popTagline');
            const popText = document.getElementById('popText');
            const galleryContainer = document.getElementById('popGallery');

            function openPopupForProject(index) {
                const project = projectsArray[index];
                if (!project) return;

                popImg.src = project.mainImage;
                // popTitle.textContent = project.title;
                popTagline.textContent = project.tagline;
                popText.textContent = project.description;


                // YouTube embed gallery, if available
                const videoGalleryContainer = document.getElementById('popVideoGallery');
                videoGalleryContainer.innerHTML = ''; // clear previous
                if (project.videoLinks && project.videoLinks.length) {
                    const embedLinks = project.videoLinks.filter(link => link.includes('embed'));
                    embedLinks.forEach(link => {
                        const videoIframe = document.createElement('iframe');
                        videoIframe.src = link;
                        videoIframe.style.width = '100%'; // Adjust width according to your design
                        videoIframe.style.height = '315px'; // Adjust height as needed
                        videoIframe.setAttribute('frameborder', '0');
                        videoIframe.setAttribute('allowfullscreen', true);
                        videoGalleryContainer.appendChild(videoIframe);
                    });
                    videoGalleryContainer.style.display = 'block';
                } else {
                    videoGalleryContainer.style.display = 'none';
                }

                // Image Gallery
                galleryContainer.innerHTML = ''; // clear previous
                if (project.ImgGallery && project.ImgGallery.length) {
                    project.ImgGallery.forEach(url => {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.objectFit = 'contain'; // ensure aspect ratio is respected
                        galleryContainer.appendChild(img);
                    });
                    galleryContainer.style.display = 'flex';
                } else {
                    galleryContainer.style.display = 'none';
                }

                popup.classList.add('active');
            }

            // for the button i think
            document.getElementById('closePopup').addEventListener('click', () => {
                popup.classList.remove('active');
            });



            let projectsArray = []; // stores the JSON once fetched

            window.addEventListener('DOMContentLoaded', () => {
            fetch('https://raw.githubusercontent.com/schreibmachine/portfolio/refs/heads/main/projects.json')
                .then(res => res.json())
                .then(data => {
                    // when data is fetched:
                    projectsArray = data; // save the array for later
                    console.log(projectsArray.length + ' projects loaded. Details: ', projectsArray);

                    // Will create a new cube every n milliseconds (intervalID needed to kill it when finished) - here, to wai
                    intervalID ??= window.setInterval(createCube, 1000);

                })
                .catch(err => console.error('Failed to load projects.json:', err));
            });
     


            // -------------------------------------------------------------------------------------------

            class RapierDebugRenderer {
                mesh
                world
                enabled = true

                constructor(scene, world) {
                    this.world = world
                    this.mesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true }))
                    this.mesh.frustumCulled = false
                    scene.add(this.mesh)
                }


                update() {
                    if (this.enabled) {
                        const { vertices, colors } = world.debugRender()
                        this.mesh.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))
                        this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4))
                        this.mesh.visible = true
                    } else {
                        this.mesh.visible = false
                    }
                }
            }

            await RAPIER.init() // This line is only needed if using the compat version
            const gravity = new RAPIER.Vector3(0.0, -9.81, 0.0)
            const world = new RAPIER.World(gravity)
            const dynamicBodies = []

            let cubeCounter = 0
            let cubeCounter_offset = 0.0
            let intervalID

            const scene = new THREE.Scene()

            const rapierDebugRenderer = new RapierDebugRenderer(scene, world)

            const light1 = new THREE.SpotLight(undefined, Math.PI * 10)
            light1.position.set(2.5, 5, 5)
            light1.angle = Math.PI / 1.8
            light1.penumbra = 0.5
            light1.castShadow = true
            light1.shadow.blurSamples = 10
            light1.shadow.radius = 5
            scene.add(light1)

            const light2 = light1.clone()
            light2.position.set(-2.5, 5, 5)
            scene.add(light2)

            const framePadding = 0.1
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100)
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100)
            camera.position.set(0, 2, 5)

            const renderer = new THREE.WebGLRenderer({ antialias: true })

            function clamp(num, min, max) {
                return Math.min(Math.max(num, min), max);
            }
            let clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 1080);
            let clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 1080);
            // renderer.setSize(clampedWidth, clampedHeight)
            //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }

            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.VSMShadowMap
            document.body.appendChild(renderer.domElement)
            renderer.domElement.id = 'myCoolRenderer'

            window.addEventListener('resize', () => {
                camera.aspect = 1 // keep square!
                camera.updateProjectionMatrix()
                clampedWidth = clamp(window.innerWidth - (framePadding * window.innerWidth), 0, 900);
                clampedHeight = clamp(window.innerHeight - (framePadding * window.innerHeight), 0, 900);

                //keep renderer square and fit to the smaller window size
                if (clampedWidth <= clampedHeight) {
                    renderer.setSize(clampedWidth, clampedWidth)
                }
                if (clampedWidth > clampedHeight) {
                    renderer.setSize(clampedHeight, clampedHeight)
                }
            })

            function createTextTexture(pText, pColor, width = 256, height = 256, padding = 10) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Background (optional)
                ctx.fillStyle = pColor;
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Function to split text into lines that fit the canvas
                function wrapText(ctx, pText, maxWidth) {
                    const words = pText.split(' ');
                    const lines = [];
                    let line = '';

                    for (let word of words) {
                        const testLine = line + (line ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && line) {
                            lines.push(line);
                            line = word;
                        } else {
                            line = testLine;
                        }
                    }
                    lines.push(line);
                    return lines;
                }

                // Start with a big font size and shrink until it fits
                let fontSize = 80;
                ctx.font = `bold ${fontSize}px Arial`;

                let lines = wrapText(ctx, pText, width - 2 * padding);

                while (lines.length * fontSize > height - 2 * padding && fontSize > 10) {
                    fontSize -= 2;
                    ctx.font = `bold ${fontSize}px Arial`;
                    lines = wrapText(ctx, pText, width - 2 * padding);
                }

                // Draw the lines centered vertically
                const lineHeight = fontSize * 1.2;
                const totalHeight = lines.length * lineHeight;
                let y = height / 2 - totalHeight / 2 + lineHeight / 2;

                for (let line of lines) {
                    ctx.fillText(line, width / 2, y);
                    y += lineHeight;
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }


            function createCube() {
                cubeCounter++;

                const id = `cube_${cubeCounter}`;

                // Create a canvas texture with the project title and color
                const projectTitle = projectsArray[cubeCounter-1]?.title || 'Error';
                const projectColor = projectsArray[cubeCounter-1]?.color || 'black';
                const textTexture = createTextTexture(projectTitle,projectColor);

                // Use MeshBasicMaterial so lighting doesn't affect visibility
                const materials = Array(6).fill(new THREE.MeshBasicMaterial({ map: textTexture }));

                const cubeMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 0.5),
                    materials
                );

                cubeMesh.name = id;
                cubeMesh.userData.body = null;  
                cubeMesh.userData.projectIndex = cubeCounter - 1; // store index for popup

                scene.add(cubeMesh);

                const cubeBody = world.createRigidBody(
                    RAPIER.RigidBodyDesc.dynamic()
                        .setTranslation(-1 + (cubeCounter % 3), 7, 2.5)
                        .setCanSleep(false)
                );

                const cubeShape = RAPIER.ColliderDesc
                    .cuboid(0.25, 0.25, 0.25)
                    .setMass(1)
                    .setRestitution(0.5);

                world.createCollider(cubeShape, cubeBody);

                cubeMesh.userData.body = cubeBody;

                dynamicBodies.push(cubeMesh);

                if (cubeCounter >= projectsArray.length) {
                    clearInterval(intervalID);
                }
            }



            function createBall(name) {
                
                // Ball Collider
                const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshNormalMaterial())
                sphereMesh.castShadow = true
                scene.add(sphereMesh)
                const sphereBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 5, 2.5).setCanSleep(false))
                const sphereShape = RAPIER.ColliderDesc.ball(.2).setMass(1).setRestitution(0.5)
                world.createCollider(sphereShape, sphereBody)
                dynamicBodies.push([sphereMesh, sphereBody])
            }

            
            /*
            // ConvexHull Collider
            const icosahedronMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), new THREE.MeshNormalMaterial())
            icosahedronMesh.castShadow = true
            scene.add(icosahedronMesh)
            const icosahedronBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2.5, 5, 0).setCanSleep(false))
            const points = new Float32Array(icosahedronMesh.geometry.attributes.position.array)
            const icosahedronShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
            world.createCollider(icosahedronShape, icosahedronBody)
            dynamicBodies.push([icosahedronMesh, icosahedronBody])

            // Trimesh Collider
            const torusKnotMesh = new THREE.Mesh(new THREE.TorusKnotGeometry(), new THREE.MeshNormalMaterial())
            torusKnotMesh.castShadow = true
            scene.add(torusKnotMesh)
            const torusKnotBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(2, 10, 0))
            const vertices = new Float32Array(torusKnotMesh.geometry.attributes.position.array)
            let indices = new Uint32Array(torusKnotMesh.geometry.index.array)
            const torusKnotShape = RAPIER.ColliderDesc.trimesh(vertices, indices).setMass(1).setRestitution(0.5)
            world.createCollider(torusKnotShape, torusKnotBody)
            dynamicBodies.push([torusKnotMesh, torusKnotBody])
            */

            // the floor (using a cuboid)
            const floorMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 1, 50), new THREE.MeshPhongMaterial({color: '#36e817', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            floorMesh.receiveShadow = true
            floorMesh.position.y = 0
            scene.add(floorMesh)
            const floorBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorMesh.position.y, 0))
            const floorShape = RAPIER.ColliderDesc.cuboid(25, 0.5, 25)
            world.createCollider(floorShape, floorBody)

            // the left side (using a cuboid)
            const sideLMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideLMesh.receiveShadow = true
            sideLMesh.position.y = -1
            sideLMesh.position.x = -2
            scene.add(sideLMesh)
            const sideLBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideLMesh.position.x, sideLMesh.position.y, sideLMesh.position.z))
            const sideLShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideLShape, sideLBody)

            // the RIGHT side (using a cuboid)
            const sideRMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 50), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideRMesh.receiveShadow = true
            sideRMesh.position.y = -1
            sideRMesh.position.x = 2
            scene.add(sideRMesh)
            const sideRBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideRMesh.position.x, sideRMesh.position.y, sideRMesh.position.z))
            const sideRShape = RAPIER.ColliderDesc.cuboid(0.5, 25, 25)
            world.createCollider(sideRShape, sideRBody)

            
            // the BACK side (using a cuboid)
            const sideBMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 1), new THREE.MeshPhongMaterial({color: '#da70b8', emissive: '#060673', specular: '#ff0000', shininess: '100'}))
            sideBMesh.receiveShadow = true
            sideBMesh.position.z = 1.5
            scene.add(sideBMesh)
            const sideBBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(sideBMesh.position.x, sideBMesh.position.y, sideBMesh.position.z))
            const sideBShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(sideBShape, sideBBody)
            
            // the FRONT side (using a cuboid) - invisible(no mat)
            const frontalBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 3.25))
            const frontalShape = RAPIER.ColliderDesc.cuboid(25, 25, 0.5)
            world.createCollider(frontalShape, frontalBody)

            /*
            // creating a shape from a loaded geometry. (Using OBJLoader)
            new OBJLoader().loadAsync('./models/suzanne.obj').then((object) => {
                //console.log(object)
                scene.add(object)
                const suzanneMesh = object.getObjectByName('Suzanne')
                suzanneMesh.material = new THREE.MeshNormalMaterial()
                suzanneMesh.castShadow = true

                const suzanneBody = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(-1, 10, 0).setCanSleep(false))
                const points = new Float32Array(suzanneMesh.geometry.attributes.position.array)
                const suzanneShape = RAPIER.ColliderDesc.convexHull(points).setMass(1).setRestitution(0.5)
                world.createCollider(suzanneShape, suzanneBody)
                dynamicBodies.push([suzanneMesh, suzanneBody])
            })
            */

            // DO STUFF WHEN CLICKING A CUBE -----------------------------------------------------
            const raycaster = new THREE.Raycaster()
            const mouse = new THREE.Vector2()

            renderer.domElement.addEventListener('pointerdown', (e) => {
                const rect = renderer.domElement.getBoundingClientRect();

                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(dynamicBodies, false);

                if (!intersects.length) return;

                const mesh = intersects[0].object;
                const body = mesh.userData.body;

                // Find the index of this mesh in dynamicBodies
                const index = dynamicBodies.indexOf(mesh);

                console.log("Clicked cube index:", index);

                if (index !== -1) {
                    // go into the AI created pop up function lol
                    openPopupForProject(index);

                    // popup.style.display = 'flex';
                }

                body.applyImpulse(new RAPIER.Vector3(0, 10, 0), true);
            });




            // const stats = new Stats()
            // document.body.appendChild(stats.dom)

            // const gui = new GUI()
            // gui.add(rapierDebugRenderer, 'enabled').name('Rapier Degug Renderer')

            // const physicsFolder = gui.addFolder('Physics')
            // physicsFolder.add(world.gravity, 'x', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'y', -10.0, 10.0, 0.1)
            // physicsFolder.add(world.gravity, 'z', -10.0, 10.0, 0.1)

            const clock = new THREE.Clock()
            let delta

            function animate() {
                requestAnimationFrame(animate)

                delta = clock.getDelta()
                world.timestep = Math.min(delta, 0.01)
                world.step()

                for (const mesh of dynamicBodies) {
                    const body = mesh.userData.body;
                    const pos = body.translation();
                    const rot = body.rotation();

                    mesh.position.set(pos.x, pos.y, pos.z);
                    mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                }


                
                // rapierDebugRenderer.update()
                
                // controls.update()
                
                renderer.render(scene, camera)
                
                // stats.update().
            }

            animate()
            
        </script>

        <div class="main" id="section2">
            <a href="#section1">Click Me to get back up!</a>
            <br>
            This website is currently under construction!
            <br>
            <br>
            <br>
            This section will be the "About Me"
        </div>
        <!-- background -->
    </body>
</html>
